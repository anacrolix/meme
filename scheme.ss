(__define list (lambda a a))
(__define define (__macro (lambda (formals . body)
  (cons '__define 
        (if (pair? formals)
            (list (car formals) (list 'lambda (cdr formals) (cons 'begin body)))
            (list formals (cons 'begin body)))))))
(define macro __macro)
(define defmacro (macro (lambda (formals . body)
  (cons '__define
        (if (pair? formals)
            (list (car formals) (list 'macro (list 'lambda (cdr formals) (cons 'begin body))))
            (list formals (list 'macro (cons 'begin body))))))))
;(define quote __quote)
;(define defined? __defined?)
;(define undef __undef)
;(define set! __set!)

(define (length x) (if (null? x) 0 (+ 1 (length (cdr x)))))
(define (unpack first . rest)
  (define (pack-exps exps)
    (if (= 1 (length exps))
      (car exps)
      (cons 'begin exps)))
  (if (eq? 'else (car first))
    (pack-exps (cdr first))
    (list 'if (car first) (pack-exps (cdr first)) (apply unpack rest))))
(defmacro (cond . clauses) (apply unpack clauses))
(define (or . tests)
  (cond ((null? tests) #f)
        ((car tests) (car tests))
        (else (apply or (cdr tests)))))
(length '(2 4 6))
(define (not x) (if x #f #t))
(define (/= . a) (not (apply = a)))
(defmacro (> a b) (list '< b a))
;(define (> a b) (< b a))
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
;(defmacro (define! formals body)
;  (define sym (if (pair? formals) (car formals) formals))
;  (list 'begin
;        (list 'if (list 'defined? sym) (list 'undef sym))
;        (list 'define formals body)))

; not sure if fold-left is supposed to reverse a given list
(define (fold-left f z p)
  (if (null? p) z (fold-left f (f (car p) z) (cdr p))))
(define (fold-right f z p)
  (if (null? p) z (f (car p) (fold-right f z (cdr p)))))
(define (map-unary f p)
  (fold-right (lambda (head tail) (cons (f head) tail)) '() p))

(define (map f . is)
  (define heads (lambda (a) (list-comp car a)))
  (define tails (lambda (a) (list-comp cdr a)))
  (if (null? (car is)) '() (cons (apply f (heads is)) (apply map f (tails is)))))
(defmacro (let bindings body1 . bodyn)
  (cons 
    (cons 'lambda (cons (map car bindings) (cons body1 bodyn)))
    (map cadr bindings)))
        
(define (list-comp f lst)
  (if (null? lst) '() (cons (f (car lst)) (list-comp f (cdr lst)))))

